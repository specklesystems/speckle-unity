<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SpeckleCore2</name>
    </assembly>
    <members>
        <member name="T:Speckle.Core.Api.SpeckleGraphQLException`1">
            <summary>
            Base class for GraphQL API exceptions
            </summary>
        </member>
        <member name="T:Speckle.Core.Api.SpeckleGraphQLForbiddenException`1">
            <summary>
            Represents a "FORBIDDEN" on "UNAUTHORIZED" GraphQL error as an exception.
            https://www.apollographql.com/docs/apollo-server/v2/data/errors/#unauthenticated
            https://www.apollographql.com/docs/apollo-server/v2/data/errors/#forbidden
            </summary>
        </member>
        <member name="M:Speckle.Core.Api.Client.ExecuteGraphQLRequest``1(GraphQL.GraphQLRequest,System.Threading.CancellationToken)">
            <exception cref="T:Speckle.Core.Api.SpeckleGraphQLForbiddenException`1">"FORBIDDEN" on "UNAUTHORIZED" response from server</exception>
            <exception cref="T:Speckle.Core.Api.SpeckleGraphQLException`1">All other request errors</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> requested a cancel</exception>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetActivity(System.String,System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.Nullable{System.DateTime},System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the activity of a stream
            </summary>
            <param name="id">Id of the stream to get the activity from</param>
            <param name="after">Only show activity after this DateTime</param>
            <param name="before">Only show activity before this DateTime</param>
            <param name="cursor">Time to filter the activity with</param>
            <param name="actionType">Time to filter the activity with</param>
            <param name="limit">Max number of activity items to get</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetBranchesWithLimitRetry(System.String,System.Int32)">
            <summary>
            Get branches from a given stream, first with a max of 500 and then with a max of 100.
            This ensures that if the server API is limiting to 100 branches, that any failure will try again at the lower value.
            </summary>
            <param name="streamId">Id of the stream to get the branches from</param>
            <param name="commitsLimit">Max number of commits to retrieve</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetBranches(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Get branches from a given stream
            </summary>
            <param name="streamId">Id of the stream to get the branches from</param>
            <param name="branchesLimit">Max number of branches to retrieve</param>
            <param name="commitsLimit">Max number of commits to retrieve</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.BranchCreate(Speckle.Core.Api.BranchCreateInput,System.Threading.CancellationToken)">
            <summary>
            Creates a branch on a stream.
            </summary>
            <param name="branchInput"></param>
            <param name="cancellationToken"></param>
            <returns>The branch id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.BranchGet(System.String,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets a given branch from a stream.
            </summary>
            <param name="streamId">Id of the stream to get the branch from</param>
            <param name="branchName">Name of the branch to get</param>
            <param name="cancellationToken"></param>
            <returns>The requested branch</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.ModelGet(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a given model from a project.
            </summary>
            <param name="cancellationToken"></param>
            <param name="projectId">Id of the project to get the model from</param>
            <param name="modelId">Id of the model</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.BranchUpdate(Speckle.Core.Api.BranchUpdateInput,System.Threading.CancellationToken)">
            <summary>
            Updates a branch.
            </summary>
            <param name="branchInput"></param>
            <returns>The stream's id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.BranchDelete(Speckle.Core.Api.BranchDeleteInput,System.Threading.CancellationToken)">
            <summary>
            Deletes a stream.
            </summary>
            <param name="branchInput"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetComments(System.String,System.Int32,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets the comments on a Stream
            </summary>
            <param name="streamId">Id of the stream to get the comments from</param>
            <param name="limit">The number of comments to get</param>
            <param name="cursor">Time to filter the comments with</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetCommentScreenshot(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets the screenshot of a Comment
            </summary>
            <param name="id">Id of the comment</param>
            <param name="streamId">Id of the stream to get the comment from</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.CommitGet(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a given commit from a stream.
            </summary>
            <param name="streamId">Id of the stream to get the commit from</param>
            <param name="commitId">Id of the commit to get</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetCommits(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets the latest commits from a stream
            </summary>
            <param name="streamId">Id of the stream to get the commits from</param>
            <param name="limit">Max number of commits to get</param>
            <param name="cancellationToken"></param>
            <returns>The requested commits</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.CommitCreate(Speckle.Core.Api.CommitCreateInput,System.Threading.CancellationToken)">
            <summary>
            Creates a commit on a branch.
            </summary>
            <param name="commitInput"></param>
            <returns>The commit id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.CommitUpdate(Speckle.Core.Api.CommitUpdateInput,System.Threading.CancellationToken)">
            <summary>
            Updates a commit.
            </summary>
            <param name="commitInput"></param>
            <param name="cancellationToken"></param>
            <returns>The stream's id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.CommitDelete(Speckle.Core.Api.CommitDeleteInput,System.Threading.CancellationToken)">
            <summary>
            Deletes a commit.
            </summary>
            <param name="commitInput"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.CommitReceived(Speckle.Core.Api.CommitReceivedInput,System.Threading.CancellationToken)">
            <summary>
            Sends a commitReceived mutation, affirming a commit has been received.
            </summary>
            <remarks>Used for read receipts</remarks>
            <param name="commitReceivedInput"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.ObjectGet(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets data about the requested Speckle object from a stream.
            </summary>
            <param name="streamId">Id of the stream to get the object from</param>
            <param name="objectId">Id of the object to get</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.ObjectCountGet(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets a given object from a stream.
            </summary>
            <param name="streamId"></param>
            <param name="objectId"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGrantPermission(Speckle.Core.Api.StreamPermissionInput)">
            <summary>
            Grants permissions to a user on a given stream.
            </summary>
            <param name="permissionInput"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGrantPermission(System.Threading.CancellationToken,Speckle.Core.Api.StreamPermissionInput)">
            <summary>
            Grants permissions to a user on a given stream.
            </summary>
            <param name="cancellationToken"></param>
            <param name="permissionInput"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.GetServerVersion(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the current server. Useful for guarding against unsupported api calls on newer or older servers.
            </summary>
            <param name="cancellationToken">[Optional] defaults to an empty cancellation token</param>
            <returns><see cref="T:Speckle.Core.Api.Version"/> object excluding any strings (eg "2.7.2-alpha.6995" becomes "2.7.2.6995")</returns>
            <exception cref="T:Speckle.Core.Logging.SpeckleException"></exception>
        </member>
        <member name="M:Speckle.Core.Api.Client.IsStreamAccessible(System.String,System.Threading.CancellationToken)">
            <summary>
            Checks if a stream exists by id.
            </summary>
            <param name="id">Id of the stream to get</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGet(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets a stream by id including basic branch info (id, name, description, and total commit count).
            For detailed commit and branch info, use <see cref="M:Speckle.Core.Api.Client.StreamGetCommits(System.String,System.Int32,System.Threading.CancellationToken)"/> and <see cref="M:Speckle.Core.Api.Client.StreamGetBranches(System.String,System.Int32,System.Int32,System.Threading.CancellationToken)"/> respectively.
            </summary>
            <param name="id">Id of the stream to get</param>
            <param name="branchesLimit">Max number of branches to retrieve</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamsGet(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets all streams for the current user
            </summary>
            <param name="limit">Max number of streams to return</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.FavoriteStreamsGet(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Gets all favorite streams for the current user
            </summary>
            <param name="limit">Max number of streams to return</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamSearch(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches the user's streams by name, description, and ID
            </summary>
            <param name="query">String query to search for</param>
            <param name="limit">Max number of streams to return</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamCreate(Speckle.Core.Api.StreamCreateInput,System.Threading.CancellationToken)">
            <summary>
            Creates a stream.
            </summary>
            <param name="streamInput"></param>
            <param name="cancellationToken"></param>
            <returns>The stream's id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamUpdate(Speckle.Core.Api.StreamUpdateInput,System.Threading.CancellationToken)">
            <summary>
            Updates a stream.
            </summary>
            <param name="streamInput">Note: the id field needs to be a valid stream id.</param>
            <param name="cancellationToken"></param>
            <returns>The stream's id.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamDelete(System.String,System.Threading.CancellationToken)">
            <summary>
            Deletes a stream.
            </summary>
            <param name="id">Id of the stream to be deleted</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamRevokePermission(Speckle.Core.Api.StreamRevokePermissionInput,System.Threading.CancellationToken)">
            <summary>
            Revokes permissions of a user on a given stream.
            </summary>
            <param name="permissionInput"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamUpdatePermission(Speckle.Core.Api.StreamPermissionInput,System.Threading.CancellationToken)">
            <summary>
            Updates permissions for a user on a given stream.
            </summary>
            <param name="updatePermissionInput">includes the streamId, the userId of the user to update, and the user's new role</param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:Speckle.Core.Logging.SpeckleException"></exception>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamGetPendingCollaborators(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets the pending collaborators of a stream by id.
            Requires the user to be an owner of the stream.
            </summary>
            <param name="streamId"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamInviteCreate(Speckle.Core.Api.StreamInviteCreateInput,System.Threading.CancellationToken)">
            <summary>
            Sends an email invite to join a stream and assigns them a collaborator role.
            </summary>
            <param name="inviteCreateInput"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamInviteCancel(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Cancels an invite to join a stream.
            </summary>
            <param name="streamId">Id of the stream</param>
            <param name="inviteId">Id of the invite to cancel</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.StreamInviteUse(System.String,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Accept or decline a stream invite.
            </summary>
            <param name="streamId"></param>
            <param name="token"></param>
            <param name="accept"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:Speckle.Core.Logging.SpeckleException"></exception>
        </member>
        <member name="M:Speckle.Core.Api.Client.ActiveUserGet(System.Threading.CancellationToken)">
            <summary>
            Gets the currently active user profile.
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.OtherUserGet(System.String,System.Threading.CancellationToken)">
            <summary>
            Get another user's profile by its user id.
            </summary>
            <param name="id">Id of the user you are looking for</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.UserSearch(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches for a user on the server.
            </summary>
            <param name="query">String to search for. Must be at least 3 characters</param>
            <param name="limit">Max number of users to return</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeBranchCreated(System.String)">
            <summary>
            Subscribe to events of branch created for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeBranchUpdated(System.String,System.String)">
            <summary>
            Subscribe to events of branch updated for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeBranchDeleted(System.String)">
            <summary>
            Subscribe to events of branch deleted for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeCommitCreated(System.String)">
            <summary>
            Subscribe to events of commit created for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeCommitUpdated(System.String,System.String)">
            <summary>
            Subscribe to events of commit updated for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeCommitDeleted(System.String)">
            <summary>
            Subscribe to events of commit updated for a stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeUserStreamAdded">
            <summary>
            Subscribe to events of streams added for the current user
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeStreamUpdated(System.String)">
            <summary>
            Subscribe to events of streams updated for a specific streamId
            </summary>
            <param name="id">streamId</param>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeUserStreamRemoved">
            <summary>
            Subscribe to events of streams removed for the current user
            </summary>
        </member>
        <member name="M:Speckle.Core.Api.Client.SubscribeCommentActivity(System.String)">
             <summary>
             Subscribe to new comment events
             </summary>
            
        </member>
        <member name="M:Speckle.Core.Api.GraphQL.GraphQLHttpClientExtensions.GetServerVersion(GraphQL.Client.Http.GraphQLHttpClient,System.Threading.CancellationToken)">
            <summary>
            Gets the version of the current server. Useful for guarding against unsupported api calls on newer or older servers.
            </summary>
            <param name="cancellationToken">[Optional] defaults to an empty cancellation token</param>
            <returns><see cref="T:Speckle.Core.Api.Version"/> object excluding any strings (eg "2.7.2-alpha.6995" becomes "2.7.2.6995")</returns>
            <exception cref="T:Speckle.Core.Api.SpeckleGraphQLException"></exception>
        </member>
        <member name="P:Speckle.Core.Api.Stream.branch">
            <summary>
            Set only in the case that you've requested this through <see cref="M:Speckle.Core.Api.Client.BranchGet(System.String,System.String,System.Int32,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.Stream.commit">
            <summary>
            Set only in the case that you've requested this through <see cref="M:Speckle.Core.Api.Client.CommitGet(System.String,System.String,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.Stream.commits">
            <summary>
            Set only in the case that you've requested this through <see cref="M:Speckle.Core.Api.Client.StreamGetCommits(System.String,System.Int32,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="T:Speckle.Core.Api.ActiveUserData">
            <summary>
            GraphQL DTO model for active user data
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.ActiveUserData.activeUser">
            <summary>
             User profile of the active user.
            </summary>
        </member>
        <member name="T:Speckle.Core.Api.LimitedUserData">
            <summary>
            GraphQL DTO model for limited user data. Mostly referring to other user's profile.
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.LimitedUserData.otherUser">
            <summary>
            The limited user profile of another (non active user)
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.ServerInfo.frontend2">
            <remarks>
            This field is not returned from the GQL API,
            it should populated on construction from the response headers.
            see <see cref="T:Speckle.Core.Credentials.AccountManager"/>
            </remarks>
        </member>
        <member name="P:Speckle.Core.Api.ServerInfo.url">
            <remarks>
            This field is not returned from the GQL API,
            it should populated on construction.
            see <see cref="T:Speckle.Core.Credentials.AccountManager"/>
            </remarks>
        </member>
        <member name="P:Speckle.Core.Api.ServerMigration.movedTo">
            <summary>
            New URI where this server is now deployed
            </summary>
        </member>
        <member name="P:Speckle.Core.Api.ServerMigration.movedFrom">
            <summary>
            Previous URI where this server used to be deployed
            </summary>
        </member>
        <member name="T:Speckle.Core.Api.Os">
            <summary>
            OS
            NOTE: do not edit order and only append new items as they are serialized to ints
            </summary>
        </member>
        <member name="T:Speckle.Core.Api.Architecture">
            <summary>
            Architecture
            NOTE: do not edit order and only append new items as they are serialized to ints
            </summary>
        </member>
        <member name="M:Speckle.Core.Api.Helpers.Receive(System.String,Speckle.Core.Credentials.Account,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.Int32})">
            <summary>
            Helper method to Receive from a Speckle Server.
            </summary>
            <param name="stream">Stream URL or Id to receive from. If the URL contains branchName, commitId or objectId those will be used, otherwise the latest commit from main will be received.</param>
            <param name="account">Account to use. If not provided the default account will be used.</param>
            <param name="onProgressAction">Action invoked on progress iterations.</param>
            <param name="onTotalChildrenCountKnown">Action invoked once the total count of objects is known.</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Helpers.Send(System.String,Speckle.Core.Models.Base,System.String,System.String,System.Int32,Speckle.Core.Credentials.Account,System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}})">
            <summary>
            Helper method to Send to a Speckle Server.
            </summary>
            <param name="stream">Stream URL or Id to send to. If the URL contains branchName, commitId or objectId those will be used, otherwise the latest commit from main will be received.</param>
            <param name="data">Data to send</param>
            <param name="account">Account to use. If not provided the default account will be used.</param>
            <param name="useDefaultCache">Toggle for the default cache. If set to false, it will only send to the provided transports.</param>
            <param name="onProgressAction">Action invoked on progress iterations.</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Helpers.IsConnectorUpdateAvailable(System.String)">
             <summary>
            
             </summary>
             <param name="slug">The connector slug eg. revit, rhino, etc</param>
             <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Helpers.TimeAgo(System.Nullable{System.DateTime},System.String)">
            <inheritdoc cref="M:Speckle.Core.Api.Helpers.TimeAgo(System.DateTime)"/>
            <param name="fallback">value to fallback to if the given <paramref name="timestamp"/> is <see langword="null"/></param>
        </member>
        <member name="M:Speckle.Core.Api.Helpers.TimeAgo(System.DateTime)">
            <summary>Formats the given difference between the current system time and the provided <paramref name="timestamp"/>
            into a human readable string
            </summary>
            <param name="timestamp"></param>
            <returns>A Human readable string</returns>
        </member>
        <member name="T:Speckle.Core.Api.Operations">
            <summary>
            Exposes several key methods for interacting with Speckle.Core.
            <para>Serialize/Deserialize</para>
            <para>Push/Pull (methods to serialize and send data to one or more servers)</para>
            </summary>
        </member>
        <member name="M:Speckle.Core.Api.Operations.GetSerializerInstance">
            <summary>
            Convenience method to instantiate an instance of the default object serializer and settings pre-populated with it.
            </summary>
        </member>
        <member name="M:Speckle.Core.Api.Operations.GetInternalProgressAction(System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}})">
            <summary>
            Factory for progress actions used internally inside send and receive methods.
            </summary>
            <param name="onProgressAction"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.Int32},System.Threading.CancellationToken)">
            <summary>
            Receives an object (and all its sub-children) from the two provided <see cref="T:Speckle.Core.Transports.ITransport"/>s.
            <br/>
            Will first try and find objects using the <paramref name="localTransport"/> (the faster transport)
            If not found, will attempt to copy the objects from the <paramref name="remoteTransport"/> into the <paramref name="localTransport"/> before deserialization
            </summary>
            <remarks>
            If Transports are properly implemented, there is no hard distinction between what is a local or remote transport; it's still just an <see cref="T:Speckle.Core.Transports.ITransport"/>.
            <br/>So, for example, if you want to receive an object without actually writing it first to a local transport, you can just pass a <see cref="T:Speckle.Core.Transports.ServerTransport"/> as a local transport.
            <br/>This is not recommended, but shows what you can do. Another tidbit: the local transport does not need to be disk-bound; it can easily be an in <see cref="T:Speckle.Core.Transports.MemoryTransport"/>. In memory transports are the fastest ones, but they're of limited use for larger datasets
            </remarks>
            <param name="objectId">The id of the object to receive</param>
            <param name="remoteTransport">The remote transport (slower). If <see langword="null"/>, will assume all objects are present in <paramref name="localTransport"/></param>
            <param name="localTransport">The local transport (faster). If <see langword="null"/>, will use a default <see cref="T:Speckle.Core.Transports.SQLiteTransport"/> cache</param>
            <param name="onProgressAction">Action invoked on progress iterations</param>
            <param name="onTotalChildrenCountKnown">Action invoked once the total count of objects is known</param>
            <param name="cancellationToken"></param>
            <exception cref="T:Speckle.Core.Transports.TransportException">Failed to retrieve objects from the provided transport(s)</exception>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleDeserializeException">Deserialization of the requested object(s) failed</exception>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> requested cancel</exception>
            <returns>The requested Speckle Object</returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.LocalReceive(System.String,Speckle.Core.Transports.ITransport,System.Action{System.Int32})">
            <summary>
            Try and get the object from the local transport. If it's there, we assume all its children are there
            This assumption is hard-wired into the <see cref="T:Speckle.Core.Serialisation.BaseObjectDeserializerV2"/>
            </summary>
            <param name="objectId"></param>
            <param name="localTransport"></param>
            <param name="onTotalChildrenCountKnown"></param>
            <returns></returns>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleDeserializeException"></exception>
        </member>
        <member name="M:Speckle.Core.Api.Operations.RemoteReceive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Int32})">
            <summary>
            Copies the requested object and all its children from <paramref name="remoteTransport"/> to <paramref name="localTransport"/>
            </summary>
            <seealso cref="M:Speckle.Core.Transports.ITransport.CopyObjectAndChildren(System.String,Speckle.Core.Transports.ITransport,System.Action{System.Int32})"/>
            <param name="objectId"></param>
            <param name="remoteTransport"></param>
            <param name="localTransport"></param>
            <param name="onTotalChildrenCountKnown"></param>
            <returns></returns>
            <exception cref="T:Speckle.Core.Transports.TransportException">Remote transport was not specified</exception>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Boolean)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.String,System.Exception})">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,System.Action{System.String,System.Exception})">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Receive(System.String,System.Threading.CancellationToken,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Action{System.Int32},System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <summary>
            Receives an object from a transport.
            </summary>
            <remarks>
            This overload is deprecated. You should consider using
            <see cref="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.Int32},System.Threading.CancellationToken)"/>
            <br/>
            The new overload no longer support <paramref name="serializerVersion"/> switching as v1 is now deprecated.
            <br/>
            We also no longer offer the option to <paramref name="disposeTransports"/>.
            You should instead handle disposal yourself
            using conventional mechanisms like the <c>using</c> keyword or try finally block<br/>
            <br/>
            This function overload will be kept around for several releases, but will eventually be removed.
            </remarks>
            <param name="objectId"></param>
            <param name="remoteTransport">The transport to receive from.</param>
            <param name="localTransport">Leave null to use the default cache.</param>
            <param name="onProgressAction">Action invoked on progress iterations.</param>
            <param name="onErrorAction">Action invoked on internal errors.</param>
            <param name="onTotalChildrenCountKnown">Action invoked once the total count of objects is known.</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,Speckle.Core.Transports.ITransport,System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)">
            <summary>
            Sends a Speckle Object to the provided <paramref name="transport"/> and (optionally) the default local cache
            </summary>
            <remarks/>
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.IReadOnlyCollection{Speckle.Core.Transports.ITransport},System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)"/>
            <param name="useDefaultCache">When <see langword="true"/>, an additional <see cref="T:Speckle.Core.Transports.SQLiteTransport"/> will be included</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="transport"/> or <paramref name="value"/> was <see langword="null"/></exception>
            <example><code>
            using ServerTransport destination = new(account, streamId);
            string objectId = await Send(mySpeckleObject, destination, true);
            </code></example>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.IReadOnlyCollection{Speckle.Core.Transports.ITransport},System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)">
            <summary>
            Sends a Speckle Object to the provided <paramref name="transports"/>
            </summary>
            <remarks>Only sends to the specified transports, the default local cache won't be used unless you also pass it in</remarks>
            <returns>The id (hash) of the object sent</returns>
            <param name="value">The object you want to send</param>
            <param name="transports">Where you want to send them</param>
            <param name="onProgressAction">Action that gets triggered on every progress tick (keeps track of all transports)</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentException">No transports were specified</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="value"/> was <see langword="null"/></exception>
            <exception cref="T:Speckle.Core.Logging.SpeckleException">Serialization or Send operation was unsuccessful</exception>
            <exception cref="T:Speckle.Core.Transports.TransportException">One or more <paramref name="transports"/> failed to send</exception>
            <exception cref="T:System.OperationCanceledException">The <paramref name="cancellationToken"/> requested cancellation</exception>
        </member>
        <member name="M:Speckle.Core.Api.Operations.SerializerSend(Speckle.Core.Models.Base,Speckle.Core.Serialisation.BaseObjectSerializerV2,System.Threading.CancellationToken)">
            <returns><inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.IReadOnlyCollection{Speckle.Core.Transports.ITransport},System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)"/></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Threading.CancellationToken,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Threading.CancellationToken,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Threading.CancellationToken,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Threading.CancellationToken,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)"/>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Threading.CancellationToken,System.Collections.Generic.List{Speckle.Core.Transports.ITransport},System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.String,System.Exception},System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <summary>
            Sends an object via the provided transports. Defaults to the local cache.
            </summary>
            <remarks>
            This overload is deprecated. You should consider using
            <br/><see cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,System.Collections.Generic.IReadOnlyCollection{Speckle.Core.Transports.ITransport},System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)"/>
            <br/>or
            <br/><see cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,Speckle.Core.Transports.ITransport,System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)"/>
            <br/>
            These new overloads no longer support <paramref name="serializerVersion"/> switching as v1 is now deprecated.
            <br/>
            We also no longer offer the option to <paramref name="disposeTransports"/>.
            You should instead handle disposal yourself
            using conventional mechanisms like the <c>using</c> keyword.<br/>
            <br/>
            This function overload will be kept around for several releases, but will eventually be removed.
            </remarks>
            <param name="object">The object you want to send.</param>
            <param name="cancellationToken">A cancellation token that can be used by other objects or threads to send notice of cancellation.</param>
            <param name="transports">Where you want to send them.</param>
            <param name="useDefaultCache">Toggle for the default cache. If set to false, it will only send to the provided transports.</param>
            <param name="onProgressAction">Action that gets triggered on every progress tick (keeps track of all transports).</param>
            <param name="onErrorAction">Use this to capture and handle any errors from within the transports.</param>
            <param name="disposeTransports"></param>
            <param name="serializerVersion"></param>
            <returns>The id (hash) of the object.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Serialize(Speckle.Core.Models.Base,System.Threading.CancellationToken)">
            <summary>
            Serializes a given object.
            </summary>
            <remarks>
            If you want to save and persist an object to Speckle Transport or Server,
            please use any of the "Send" methods.
            <see cref="M:Speckle.Core.Api.Operations.Send(Speckle.Core.Models.Base,Speckle.Core.Transports.ITransport,System.Boolean,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Threading.CancellationToken)"/>
            </remarks>
            <param name="value">The object to serialise</param>
            <param name="cancellationToken"></param>
            <returns>A json string representation of the object.</returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Deserialize(System.String,System.Threading.CancellationToken)">
            <remarks>
            Note: if you want to pull an object from a Speckle Transport or Server,
            please use
            <see cref="M:Speckle.Core.Api.Operations.Receive(System.String,Speckle.Core.Transports.ITransport,Speckle.Core.Transports.ITransport,System.Action{System.Collections.Concurrent.ConcurrentDictionary{System.String,System.Int32}},System.Action{System.Int32},System.Threading.CancellationToken)"/>
            </remarks>
            <param name="value">The json string representation of a speckle object that you want to deserialize</param>
            <param name="cancellationToken"></param>
            <returns><inheritdoc cref="M:Speckle.Core.Serialisation.BaseObjectDeserializerV2.Deserialize(System.String)"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> was null</exception>
            <exception cref="T:Speckle.Newtonsoft.Json.JsonReaderException"><paramref name="value"/> was not valid JSON</exception>
            <exception cref="T:Speckle.Core.Logging.SpeckleException"><paramref name="value"/> cannot be deserialised to type <see cref="T:Speckle.Core.Models.Base"/></exception>
            <exception cref="T:Speckle.Core.Transports.TransportException"><paramref name="value"/> contains closure references (see Remarks)</exception>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Serialize(System.Collections.Generic.List{Speckle.Core.Models.Base})">
            <summary>
            Serializes a list of objects. Note: if you want to save and persist objects to speckle, please use any of the "Send" methods.
            </summary>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Api.Operations.Serialize(System.Collections.Generic.Dictionary{System.String,Speckle.Core.Models.Base})">
            <summary>
            Serializes a list of objects. Note: if you want to save and persist objects to speckle, please use any of the "Send" methods.
            </summary>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="T:Speckle.Core.Api.ServerLimits">
            <summary>
            Defines the limits for specific API calls on the Speckle Server.
            These are magic numbers! Should be aligned with server always.
            </summary>
            <remarks>
            ⚠️ Not all limits are reflected here!
            </remarks>
        </member>
        <member name="M:Speckle.Core.Credentials.Account.GetLocalIdentifier">
            <summary>
            Retrieves the local identifier for the current user.
            </summary>
            <returns>
            Returns a <see cref="T:System.Uri"/> object representing the local identifier for the current user.
            The local identifier is created by appending the user ID as a query parameter to the server URL.
            </returns>
            <remarks>
            Notice that the generated Uri is not intended to be used as a functioning Uri, but rather as a
            unique identifier for a specific account in a local environment. The format of the Uri, containing a query parameter with the user ID,
            serves this specific purpose. Therefore, it should not be used for forming network requests or
            expecting it to lead to an actual webpage. The primary intent of this Uri is for unique identification in a Uri format.
            </remarks>
            <example>
              This sample shows how to call the GetLocalIdentifier method.
              <code>
                Uri localIdentifier = GetLocalIdentifier();
                Console.WriteLine(localIdentifier);
              </code>
              For a fictional `User ID: 123` and `Server: https://speckle.xyz`, the output might look like this:
              <code>
                https://speckle.xyz?id=123
              </code>
            </example>
        </member>
        <member name="T:Speckle.Core.Credentials.AccountManager">
            <summary>
            Manage accounts locally for desktop applications.
            </summary>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetServerInfo(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Gets the basic information about a server.
            </summary>
            <param name="server">Server URL</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetUserInfo(System.String,System.Uri,System.Threading.CancellationToken)">
            <summary>
            Gets basic user information given a token and a server.
            </summary>
            <param name="token"></param>
            <param name="server">Server URL</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetUserServerInfo(System.String,System.Uri,System.Threading.CancellationToken)">
            <summary>
            Gets basic user and server information given a token and a server.
            </summary>
            <param name="token"></param>
            <param name="server">Server URL</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetDefaultServerUrl">
            <summary>
            The Default Server URL for authentication, can be overridden by placing a file with the alternatrive url in the Speckle folder or with an ENV_VAR
            </summary>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.UpgradeAccount(System.String)">
            <summary>
            Upgrades an account from the account.serverInfo.movedFrom account to the account.serverInfo.movedTo account
            </summary>
            <param name="id">Id of the account to upgrade</param>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetAccounts(System.String)">
            <summary>
            Returns all unique accounts matching the serverUrl provided. If an account exists on more than one server,
            typically because it has been migrated, then only the upgraded account (and therefore server) are returned.
            Accounts are deemed to be the same when the Account.Id matches.
            </summary>
            <param name="serverUrl"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetDefaultAccount">
            <summary>
            Gets this environment's default account if any. If there is no default, the first found will be returned and set as default.
            </summary>
            <returns>The default account or null.</returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetAccounts">
            <summary>
            Gets all the accounts present in this environment.
            </summary>
            <remarks>This function does have potential side effects. Any invalid accounts found while enumerating will be removed</remarks>
            <returns>Un-enumerated enumerable of accounts</returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetLocalAccounts">
            <summary>
            Gets the local accounts
            These are accounts not handled by Manager and are stored in json format in a local directory
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.UpdateAccounts(System.Threading.CancellationToken)">
            <summary>
            Refetches user and server info for each account
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.RemoveAccount(System.String)">
            <summary>
            Removes an account
            </summary>
            <param name="id">ID of the account to remove</param>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.ChangeDefaultAccount(System.String)">
            <summary>
            Changes the default account
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetLocalIdentifierForAccount(Speckle.Core.Credentials.Account)">
            <summary>
            Retrieves the local identifier for the specified account.
            </summary>
            <param name="account">The account for which to retrieve the local identifier.</param>
            <returns>The local identifier for the specified account in the form of "SERVER_URL?u=USER_ID".</returns>
            <remarks>
            <inheritdoc cref="M:Speckle.Core.Credentials.Account.GetLocalIdentifier"/>
            </remarks>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetAccountForLocalIdentifier(System.Uri)">
            <summary>
            Gets the account that corresponds to the given local identifier.
            </summary>
            <param name="localIdentifier">The local identifier of the account.</param>
            <returns>The account that matches the local identifier, or null if no match is found.</returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.AddAccount(System.String)">
            <summary>
            Adds an account by propting the user to log in via a web flow
            </summary>
            <param name="server">Server to use to add the account, if not provied the default Server will be used</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.IsFrontend2Server(System.Uri)">
            <summary>
            Sends a simple get request to the <paramref name="server"/>, and checks the response headers for a <c>"x-speckle-frontend-2"</c> <see cref="T:System.Boolean"/> value
            </summary>
            <param name="server">Server endpoint to get header</param>
            <returns><see langword="true"/> if response contains FE2 header and the value was <see langword="true"/></returns>
            <exception cref="T:Speckle.Core.Logging.SpeckleException">response contained FE2 header, but the value was <see langword="null"/>, empty, or not parseable to a <see cref="T:System.Boolean"/></exception>
            <exception cref="T:System.Net.Http.HttpRequestException">Request to <paramref name="server"/> failed to send or response was not successful</exception>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetServerInfo(System.String)">
            <inheritdoc cref="M:Speckle.Core.Credentials.AccountManager.GetServerInfo(System.Uri,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Speckle.Core.Credentials.AccountManager.GetUserInfo(System.String,System.String)">
            <inheritdoc cref="M:Speckle.Core.Credentials.AccountManager.GetUserInfo(System.String,System.Uri,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.#ctor(System.String)">
            <summary>
            Creates a StreamWrapper from a stream url or a stream id
            </summary>
            <param name="streamUrlOrId">Stream Url eg: http://speckle.server/streams/8fecc9aa6d/commits/76a23d7179  or stream ID eg: 8fecc9aa6d</param>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a StreamWrapper by streamId, userId and serverUrl
            </summary>
            <param name="streamId"></param>
            <param name="userId"></param>
            <param name="serverUrl"></param>
        </member>
        <member name="P:Speckle.Core.Credentials.StreamWrapper.BranchName">
            <remarks>May be an ID instead for FE2 urls</remarks>
        </member>
        <member name="P:Speckle.Core.Credentials.StreamWrapper.IsValid">
            <summary>
            Determines if the current stream wrapper contains a valid stream.
            </summary>
        </member>
        <member name="F:Speckle.Core.Credentials.StreamWrapper.s_fe2UrlRegex">
            <summary>
            The ReGex pattern to determine if a URL's AbsolutePath is a Frontend2 URL or not.
            This is used in conjunction with <see cref="M:Speckle.Core.Credentials.StreamWrapper.ParseFe2ModelValue(System.String)"/> to extract the correct values into the instance.
            </summary>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.ParseFe2RegexMatch(System.Text.RegularExpressions.Match)">
            <summary>
            Parses a FrontEnd2 URL Regex match and assigns it's data to this StreamWrapper instance.
            </summary>
            <param name="match">A regex match coming from <see cref="F:Speckle.Core.Credentials.StreamWrapper.s_fe2UrlRegex"/></param>
            <exception cref="T:Speckle.Core.Logging.SpeckleException">Will throw when the URL is not properly formatted.</exception>
            <exception cref="T:System.NotSupportedException">Will throw when the URL is correct, but is not currently supported by the StreamWrapper class.</exception>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.ParseFe2ModelValue(System.String)">
            <summary>
            Parses the segment of the FE2 URL that represents a modelID, modelID@versionID or objectID.
            It is meant to parse a single value. If url is multi-model it should be used once per model.
            </summary>
            <param name="modelValue">The a single value of the model url segment</param>
            <returns>A tuple containing the branch, commit and object information for that value. Each value can be null</returns>
            <remarks>Determines if a modelValue is an ObjectId by checking it's length is exactly 32 chars long.</remarks>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.GetAccount">
            <summary>
            Gets a valid account for this stream wrapper.
            <para>Note: this method ensures that the stream exists and/or that the user has an account which has access to that stream. If used in a sync manner, make sure it's not blocking.</para>
            </summary>
            <exception cref="T:Speckle.Core.Logging.SpeckleException">Throws exception if account fetching failed. This could be due to non-existent account or stream.</exception>
            <returns>The valid account object for this stream.</returns>
        </member>
        <member name="M:Speckle.Core.Credentials.StreamWrapper.ValidateWithAccount(Speckle.Core.Credentials.Account)">
            <summary>
            Verifies that the state of the stream wrapper represents a valid Speckle resource e.g. points to a valid stream/branch etc.
            </summary>
            <param name="acc">The account to use to verify the current state of the stream wrapper</param>
            <exception cref="T:System.ArgumentException">The <see cref="T:Speckle.Core.Api.ServerInfo"/> of the provided <paramref name="acc"/> is invalid or does not match the <see cref="T:Speckle.Core.Credentials.StreamWrapper"/>'s <see cref="P:Speckle.Core.Credentials.StreamWrapper.ServerUrl"/></exception>
            <exception cref="T:System.Net.Http.HttpRequestException">You are not connected to the internet</exception>
            <exception cref="T:Speckle.Core.Logging.SpeckleException">Verification of the current state of the stream wrapper with provided <paramref name="acc"/> was unsuccessful. The <paramref name="acc"/> could be invalid, or lack permissions for the <see cref="P:Speckle.Core.Credentials.StreamWrapper.StreamId"/>, or the <see cref="P:Speckle.Core.Credentials.StreamWrapper.StreamId"/> or <see cref="P:Speckle.Core.Credentials.StreamWrapper.BranchName"/> are invalid</exception>
        </member>
        <member name="M:Speckle.Core.Helpers.Crypt.Sha256(System.String,System.String,System.Int32,System.Int32)">
            <param name="input">the value to hash</param>
            <param name="format">NumericFormat</param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns>the hash string</returns>
            <exception cref="T:System.FormatException"><paramref name="format"/> is not a recognised numeric format</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><inheritdoc cref="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)"/></exception>
        </member>
        <member name="M:Speckle.Core.Helpers.Crypt.Md5(System.String,System.String,System.Int32,System.Int32)">
            <inheritdoc cref="M:Speckle.Core.Helpers.Crypt.Sha256(System.String,System.String,System.Int32,System.Int32)"/>
            <remarks>MD5 is a broken cryptographic algorithm and should be used subject to review see CA5351</remarks>
        </member>
        <member name="M:Speckle.Core.Helpers.Http.UserHasInternet">
            <summary>
            Checks if the user has a valid internet connection by first pinging cloudfare (fast)
            and then trying get from the default Speckle server (slower)
            </summary>
            <returns>True if the user is connected to the internet, false otherwise.</returns>
        </member>
        <member name="M:Speckle.Core.Helpers.Http.Ping(System.String)">
            <summary>
            Pings a specific url to verify it's accessible. Retries 3 times.
            </summary>
            <param name="hostnameOrAddress">The hostname or address to ping.</param>
            <returns>True if the the status code is 200, false otherwise.</returns>
        </member>
        <member name="M:Speckle.Core.Helpers.Http.HttpPing(System.Uri)">
            <summary>
            Sends a <c>GET</c> request to the provided <paramref name="uri"/>
            </summary>
            <param name="uri">The URI that should be pinged</param>
            <exception cref="T:System.Net.Http.HttpRequestException">Request to <paramref name="uri"/> failed</exception>
        </member>
        <member name="M:Speckle.Core.Helpers.SpeckleHttpClientHandler.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)">
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> requested cancel</exception>
            <exception cref="T:System.Net.Http.HttpRequestException">Send request failed</exception>
        </member>
        <member name="T:Speckle.Core.Helpers.SpecklePathProvider">
            <summary>
            Helper class dedicated for Speckle specific Path operations.
            </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.InstallApplicationDataPath">
            <summary>
            Get the installation path.
            </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.InstallSpeckleFolderPath">
            <summary>
            Get the path where the Speckle applications should be installed
            </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.UserSpeckleFolderPath">
            <summary>
            Get the folder where the user's Speckle data should be stored.
            </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.KitsFolderPath">
            <summary>
            Get the folder where the Speckle kits should be stored.
            </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.ObjectsFolderPath">
             <summary>
            
             </summary>
        </member>
        <member name="P:Speckle.Core.Helpers.SpecklePathProvider.AccountsFolderPath">
            <summary>
            Get the folder where the Speckle accounts data should be stored.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideApplicationName(System.String)">
            <summary>
            Override the global Speckle application name.
            </summary>
            <param name="applicationName"></param>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideApplicationDataPath(System.String)">
            <summary>
            Override the global Speckle application data path.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideBlobStorageFolder(System.String)">
            <summary>
            Override the global Blob storage folder name.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideKitsFolderName(System.String)">
            <summary>
             Override the global Kits folder name.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideAccountsFolderName(System.String)">
            <summary>
            Override the global Accounts folder name.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.OverrideObjectsFolderName(System.String)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.UserApplicationDataPath">
            <summary>
            Get the platform specific user configuration folder path.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.BlobStoragePath(System.String)">
            <summary>
            Get the folder where the user's Speckle blobs should be stored.
            </summary>
        </member>
        <member name="M:Speckle.Core.Helpers.SpecklePathProvider.LogFolderPath(System.String,System.String)">
            <summary>
            Get the folder where the Speckle logs should be stored.
            </summary>
            <param name="hostApplicationName">Name of the application using this SDK ie.: "Rhino"</param>
            <param name="hostApplicationVersion">Public version slug of the application using this SDK ie.: "2023"</param>
        </member>
        <member name="M:Speckle.Core.Kits.HostApplication.GetVersion(Speckle.Core.Kits.HostAppVersion)">
            <summary>
            Returns the versioned app name given a specific version
            </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="T:Speckle.Core.Kits.HostApplications">
            <summary>
            List of Host Applications - their slugs should match our ghost tags and ci/cd slugs
            </summary>
        </member>
        <member name="M:Speckle.Core.Kits.HostApplications.GetHostAppFromString(System.String)">
            <summary>
            Gets a HostApplication form a string. It could be the versioned name or a string coming from a process running.
            </summary>
            <param name="appname">String with the name of the app</param>
            <returns></returns>
        </member>
        <member name="T:Speckle.Core.Kits.SchemaMainParam">
            <summary>
            Used to indicate which is the main input parameter of the schema builder component. Schema info will be attached to this object.
            </summary>
        </member>
        <member name="T:Speckle.Core.Kits.SchemaIgnore">
            <summary>
            Used to ignore properties from expand objects etc
            </summary>
        </member>
        <member name="T:Speckle.Core.Kits.KitException">
            <summary>
            Exception thrown when an <see cref="T:Speckle.Core.Kits.ISpeckleKit"/> fails to load/initialise
            </summary>
            <remarks>
            Does NOT inherit from <see cref="T:Speckle.Core.Logging.SpeckleException"/>, because this usage of this exception is not dependent on Speckle Data (user data)
            Ideally, this exception should contain a meaningful message, and a reference to the <see cref="T:Speckle.Core.Kits.ISpeckleKit"/>
            </remarks>
        </member>
        <member name="P:Speckle.Core.Kits.KitException.Kit">
            <summary>
            A reference to the <see cref="T:Speckle.Core.Kits.ISpeckleKit"/> that failed to perform
            </summary>
        </member>
        <member name="T:Speckle.Core.Kits.ConversionException">
            <summary>
            Exception thrown when conversion of an object was not successful
            </summary>
            <remarks>
            Ideally this exception contains a meaningful message, and reference to the object that failed to be converted.
            This exception can be used for both ToSpeckle and ToNative conversion
            </remarks>
        </member>
        <member name="T:Speckle.Core.Kits.ConversionNotSupportedException">
            <summary>
            Exception used when an object could not be converted, because we don't support a specific conversion.
            </summary>
            <remarks>
            This Exception should be thrown as part of a pre-emptive check in conversions (not as part reactive error handling)
            and usage (throwing) should not be dependent on external state:
            i.e. given the same object and converter state, the outcome (exception throw or not) should be the same.
            </remarks>
            <example>
            It can be used for:
            <ul>
             <li> objects who's <see cref="T:System.Type"/> we don't support (e.g. <c>"Walls are not supported"</c>)</li>
             <li> objects with a property who's value we don't support (e.g. <c>"Beams with shape type of Circular are not supported"</c>)</li>
             <li> complex object requirements (e.g. <c>"We don't support walls with zero width and no displayValue"</c>)</li>
            </ul>
            It should <b>NOT</b> be used for:
            <ul>
             <li> Invalid Speckle Objects (e.g. <c>"We don't support walls with null lines"</c>)</li>
             <li> Objects that we have already converted, and therefore now skip (e.g. <c>"A Wall with the same name was already converted"</c>)</li>
             <li> Reactive error handling (e.g. "Failed to convert wall, I guess it wasn't supported")</li>
            </ul>
            </example>
        </member>
        <member name="T:Speckle.Core.Kits.ConversionSkippedException">
            <summary>
            Exception thrown when an object was desirably skipped<br/>
            </summary>
            <remarks>
            <b>Avoid throwing this exception Type!</b><br/>
            As it introduces some bad patterns for exception handling.
            <br/>
            Namely, it encodes how the exception WILL be handled, Not simply what HAS happened.
            Exceptions shouldn't care how they are handled.
            <br/>
            We were also misusing this exception in Revit, to correct for ambiguity in the way certain objects should be traversed,
            by selectively skipping objects that were already converted by other means.
            </remarks>
        </member>
        <member name="T:Speckle.Core.Kits.ConversionNotReadyException">
            <summary>
            Exception thrown when an object was not ready to be baked into the document (i.e. the element's host doesn't exist yet)
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleConverter.Report">
            <summary>
            Keeps track of the conversion process
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleConverter.ReceiveMode">
            <summary>
            Decides what to do when an element being received already exists
            </summary>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToSpeckle(System.Object)">
            <summary>
            Converts a native object to a Speckle one
            </summary>
            <param name="value">Native object to convert</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToSpeckle(System.Collections.Generic.List{System.Object})">
            <summary>
            Converts a list of objects to Speckle.
            </summary>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToSpeckle(System.Object)">
            <summary>
            Checks if it can convert a native object to a Speckle one
            </summary>
            <param name="value">Native object to convert</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNative(Speckle.Core.Models.Base)">
            <summary>
            Converts a Speckle object to a native one
            </summary>
            <param name="value">Speckle object to convert</param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNative(System.Collections.Generic.List{Speckle.Core.Models.Base})">
            <summary>
            Converts a list of Speckle objects to a native ones.
            </summary>
            <param name="values"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNativeDisplayable(Speckle.Core.Models.Base)">
            <summary>
            Converts a given speckle objects as a generic native object.
            This should assume <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNativeDisplayable(Speckle.Core.Models.Base)"/> has been called and returned True,
            or call it within this method's implementation to ensure non-displayable objects are gracefully handled.
            </summary>
            <remarks>
            This method should not try to convert an object to it's native representation (i.e Speckle Wall -> Wall),
            but rather use the 'displayValue' of that wall to create a geometrically correct representation of that object
            in the native application.
            An object may be able to be converted both with <see cref="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNative(Speckle.Core.Models.Base)"/> and <see cref="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNativeDisplayable(Speckle.Core.Models.Base)"/>.
            In this case, deciding which to use is dependent on each connector developer.
            Preferably, <see cref="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNativeDisplayable(Speckle.Core.Models.Base)"/> should be used as a fallback to the <see cref="M:Speckle.Core.Kits.ISpeckleConverter.ConvertToNative(Speckle.Core.Models.Base)"/> logic.
            </remarks>
            <param name="value">Speckle object to convert</param>
            <returns>The native object that resulted after converting the input <paramref name="value"/></returns>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNative(Speckle.Core.Models.Base)">
            <summary>
            Checks if it can convert a Speckle object to a native one
            </summary>
            <param name="value">Speckle object to convert</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNativeDisplayable(Speckle.Core.Models.Base)">
            <summary>
            Checks to verify if a given object is: 1) displayable and  2) can be supported for conversion to the native application.
            An object is considered "displayable" if it has a 'displayValue' property (defined in its class or dynamically attached to it, detached or not).
            </summary>
            <remarks>
            An object may return "True" for both <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNative(Speckle.Core.Models.Base)"/> and <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNativeDisplayable(Speckle.Core.Models.Base)"/>
            In this case, deciding which to use is dependent on each connector developer.
            Preferably, <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNativeDisplayable(Speckle.Core.Models.Base)"/> should be used as a fallback to the <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNative(Speckle.Core.Models.Base)"/> logic.
            Objects found in the 'displayValue' property are assumed to be universally convertible by all converters and the viewer, but are not guaranteed to be so.
            </remarks>
            <param name="value">Speckle object to convert</param>
            <returns>True if the object is "displayable" and the converter supports native conversion of the given speckle object in particular.</returns>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.GetServicedApplications">
            <summary>
            Returns a list of applications serviced by this converter
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.SetContextDocument(System.Object)">
            <summary>
            Sets the application document that the converter is targeting
            </summary>
            <param name="doc">The current application document</param>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.SetContextObjects(System.Collections.Generic.List{Speckle.Core.Models.ApplicationObject})">
            <summary>
            Some converters need to know which other objects are being converted, in order to sort relationships between them (ie, Revit). Use this method to set them.
            </summary>
            <param name="objects"></param>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.SetPreviousContextObjects(System.Collections.Generic.List{Speckle.Core.Models.ApplicationObject})">
            <summary>
            Some converters need to know which objects have been converted before in order to update them (ie, Revit). Use this method to set them.
            </summary>
            <param name="objects"></param>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleConverter.SetConverterSettings(System.Object)">
            <summary>
            Some converters need to be able to receive some settings to modify their internal behaviour (i.e. Rhino's Brep Meshing options). Use this method to set them.
            </summary>
            <param name="settings">The object representing the settings for your converter.</param>
        </member>
        <member name="T:Speckle.Core.Kits.ReceiveMode">
            <summary>
            Receive modes indicate what to do and not do when receiving objects
            </summary>
        </member>
        <member name="F:Speckle.Core.Kits.ReceiveMode.Update">
            <summary>
            Attemts updating previously received objects by ID, deletes previously received objects that do not exist anymore and creates new ones
            </summary>
        </member>
        <member name="F:Speckle.Core.Kits.ReceiveMode.Create">
            <summary>
            Always creates new objects
            </summary>
        </member>
        <member name="F:Speckle.Core.Kits.ReceiveMode.Ignore">
            <summary>
            Ignores updating previously received objects and does not attempt updating or deleting them, creates new objects
            </summary>
        </member>
        <member name="T:Speckle.Core.Kits.ISpeckleKit">
            <summary>
            Defines the basic interface for creating a "Speckle Kit"
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.Types">
            <summary>
            Gets all the object types (the object model) provided by this kit.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.Converters">
            <summary>
            Gets all available converters for this Kit.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.Description">
            <summary>
            Gets this Kit's description.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.Name">
            <summary>
            Gets this Kit's name.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.Author">
            <summary>
            Gets this Kit's author.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.ISpeckleKit.WebsiteOrEmail">
            <summary>
            Gets the website (or email) to contact the Kit's author.
            </summary>
        </member>
        <member name="M:Speckle.Core.Kits.ISpeckleKit.LoadConverter(System.String)">
            <summary>
            Tries to load a converter for a specific <paramref name="app"/>.
            </summary>
            <param name="app">The host app string for which a <see cref="T:Speckle.Core.Kits.ISpeckleConverter"/> is desired. see <see cref="M:Speckle.Core.Kits.ISpeckleConverter.GetServicedApplications"/></param>
            <returns>The converter for the specific <paramref name="app"/></returns>
            <exception cref="T:Speckle.Core.Kits.KitException">Thrown if the requested converter failed to load</exception>
        </member>
        <member name="T:Speckle.Core.Kits.CoreKit">
            <summary>
            Needed so we can properly deserialize all the Base-derived objects from Core itself.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.KitManager.KitsFolder">
            <summary>
            Local installations store kits in C:\Users\USERNAME\AppData\Roaming\Speckle\Kits
            Admin/System-wide installations in C:\ProgramData\Speckle\Kits
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.KitManager.Kits">
            <summary>
            Returns a list of all the kits found on this user's device.
            </summary>
        </member>
        <member name="P:Speckle.Core.Kits.KitManager.Types">
            <summary>
            Returns a list of all the types found in all the kits on this user's device.
            </summary>
        </member>
        <member name="M:Speckle.Core.Kits.KitManager.HasKit(System.String)">
            <summary>
            Checks whether a specific kit exists.
            </summary>
            <param name="assemblyFullName"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.KitManager.GetKit(System.String)">
            <summary>
            Gets a specific kit.
            </summary>
            <param name="assemblyFullName"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.KitManager.GetDefaultKit">
            <summary>
            Gets the default Speckle provided kit, "Objects".
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.KitManager.GetKitsWithConvertersForApp(System.String)">
            <summary>
            Returns all the kits with potential converters for the software app.
            </summary>
            <param name="app"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.KitManager.Initialize(System.String)">
            <summary>
            Tells the kit manager to initialise from a specific location.
            </summary>
            <param name="kitFolderLocation"></param>
        </member>
        <member name="M:Speckle.Core.Kits.AssemblyExtensions.IsReferencing(System.Reflection.Assembly,System.Reflection.AssemblyName)">
            <summary>
            Indicates if a given assembly references another which is identified by its name.
            </summary>
            <param name="assembly">The assembly which will be probed.</param>
            <param name="referenceName">The reference assembly name.</param>
            <returns>A boolean value indicating if there is a reference.</returns>
        </member>
        <member name="F:Speckle.Core.Kits.Units.Feet">
            <summary>International Foot</summary>
        </member>
        <member name="F:Speckle.Core.Kits.Units.USFeet">
            <summary>US Survey foot</summary>
            <remarks>Considered an obsolete unit, superseded by the international foot <seealso cref="F:Speckle.Core.Kits.Units.Feet"/></remarks>
        </member>
        <member name="M:Speckle.Core.Kits.Units.IsUnitSupported(System.String)">
            <param name="unit"></param>
            <returns><see langword="true"/> if <paramref name="unit"/> is a recognised/supported unit string, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:Speckle.Core.Kits.Units.GetConversionFactor(System.String,System.String)">
            <summary>
            Gets the conversion factor from one unit system to another
            </summary>
            <param name="from">Semantic unit string for the units to convert from</param>
            <param name="to">Semantic unit string for the units to convert to</param>
            <exception cref="T:System.ArgumentOutOfRangeException">A <inheritdoc cref="M:Speckle.Core.Kits.Units.GetUnitsFromString(System.String)"/></exception>
            <returns>The scaling factor to convert from the <paramref name="from"/> units to the <paramref name="to"/> units, or 1 if either unit param is null or none</returns>
        </member>
        <member name="M:Speckle.Core.Kits.Units.GetUnitsFromString(System.String)">
            <summary>
            Given <paramref name="unit"/>, maps several friendly unit aliases to a a semantic unit string
            </summary>
            <param name="unit"></param>
            <returns>The semantic unit string, <see langword="null"/> if <paramref name="unit"/> is <see langword="null"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Unit string is not a supported unit (see <see cref="M:Speckle.Core.Kits.Units.IsUnitSupported(System.String)"/>)</exception>
        </member>
        <member name="M:Speckle.Core.Kits.Units.GetEncodingFromUnit(System.String)">
            <summary>
            Maps semantic unit strings to a numeric encoding
            </summary>
            <param name="unit"></param>
            <remarks>non-recognised unit encodings will be silently mapped to <c>0</c></remarks>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Kits.Units.GetUnitFromEncoding(System.Double)">
            <summary>
            Maps a numeric encoding to the semantic unit string
            </summary>
            <param name="unit">numeric encoded unit</param>
            <remarks>non-recognised unit encodings will be silently mapped to <see cref="F:Speckle.Core.Kits.Units.None"/></remarks>
            <returns>Semantic unit string</returns>
        </member>
        <member name="T:Speckle.Core.Logging.Analytics">
            <summary>
             Anonymous telemetry to help us understand how to make a better Speckle.
             This really helps us to deliver a better open source project and product!
            </summary>
        </member>
        <member name="T:Speckle.Core.Logging.Analytics.Events">
            <summary>
            Default Mixpanel events
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.Send">
            <summary>
            Event triggered when data is sent to a Speckle Server
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.Receive">
            <summary>
            Event triggered when data is received from a Speckle Server
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.NodeRun">
            <summary>
            Event triggered when a node is executed in a visual programming environment, it should contain the name of the action and the host application
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.DUIAction">
            <summary>
            Event triggered when an action is executed in Desktop UI, it should contain the name of the action and the host application
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.NodeCreate">
            <summary>
            Event triggered when a node is first created in a visual programming environment, it should contain the name of the action and the host application
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.ImportExportAlert">
            <summary>
            Event triggered when the import/export alert is launched or closed
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.Registered">
            <summary>
            Event triggered when the connector is registered
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.MappingsAction">
            <summary>
            Event triggered by the Mapping Tool
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.ConvertToSpeckle">
            <summary>
            Event triggered when user selects object to convert to Speckle on Send
            </summary>
        </member>
        <member name="F:Speckle.Core.Logging.Analytics.Events.ConvertToNative">
            <summary>
            Event triggered when user selects object to convert to Native on Receive
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.Analytics.LastEmail">
            <summary>
            Cached email
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.Analytics.LastServer">
            <summary>
            Cached server URL
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.Analytics.IsReleaseMode">
            <summary>
            <see langword="false"/> when the DEBUG pre-processor directive is <see langword="true"/>, <see langword="false"/> otherwise
            </summary>
            <remarks>This must be kept as a computed property, not a compile time const</remarks>
        </member>
        <member name="M:Speckle.Core.Logging.Analytics.TrackEvent(Speckle.Core.Logging.Analytics.Events,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Tracks an event without specifying the email and server.
            It's not always possible to know which account the user has selected, especially in visual programming.
            Therefore we are caching the email and server values so that they can be used also when nodes such as "Serialize" are used.
            If no account info is cached, we use the default account data.
            </summary>
            <param name="eventName">Name of the even</param>
            <param name="customProperties">Additional parameters to pass in to event</param>
            <param name="isAction">True if it's an action performed by a logged user</param>
        </member>
        <member name="M:Speckle.Core.Logging.Analytics.TrackEvent(Speckle.Core.Credentials.Account,Speckle.Core.Logging.Analytics.Events,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Tracks an event from a specified account, anonymizes personal information
            </summary>
            <param name="account">Account to use, it will be anonymized</param>
            <param name="eventName">Name of the event</param>
            <param name="customProperties">Additional parameters to pass to the event</param>
            <param name="isAction">True if it's an action performed by a logged user</param>
        </member>
        <member name="M:Speckle.Core.Logging.Analytics.TrackEvent(System.String,System.String,Speckle.Core.Logging.Analytics.Events,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Tracks an event from a specified email and server, anonymizes personal information
            </summary>
            <param name="hashedEmail">Email of the user anonymized</param>
            <param name="hashedServer">Server URL anonymized</param>
            <param name="eventName">Name of the event</param>
            <param name="customProperties">Additional parameters to pass to the event</param>
            <param name="isAction">True if it's an action performed by a logged user</param>
        </member>
        <member name="M:Speckle.Core.Logging.ExceptionHelpers.IsFatal(System.Exception)">
            <summary>
            Helper function for catch blocks to avoid catching and handling/wrapping of some critical exception types that are unlikely to be truly handleable
            </summary>
            <remarks>
            We should aim to always catch specific exception types, and have all functions document the types they may throw.
            However, this is not always achievable.
            e.g. when dealing with legacy code, some third-party APIs, or in cases where we want to prevent a host app crash.
            In these cases, we often want to catch all exceptions, and opt out only of the ones that definitely shouldn't be handled
            </remarks>
            <example>
            <code>
            try
            {
                SomethingSketchy();
            }
            catch (Exception ex) when (!IsFatal(ex))
            {
               throw new SpeckleException("Failed to do something", ex);
            }
            </code>
            </example>
            <param name="ex"></param>
            <returns><see langword="true"/> for types that are unlikely to ever be recoverable</returns>
        </member>
        <member name="T:Speckle.Core.Logging.Setup">
            <summary>
             Anonymous telemetry to help us understand how to make a better Speckle.
             This really helps us to deliver a better open source project and product!
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.Setup.HostApplication">
            <summary>
            Set from the connectors, defines which current host application we're running on.
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.Setup.VersionedHostApplication">
            <summary>
            Set from the connectors, defines which current host application we're running on - includes the version.
            </summary>
        </member>
        <member name="T:Speckle.Core.Logging.SpeckleLogConfiguration">
            <summary>
            Configuration object for the Speckle logging system.
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.EnhancedLogContext">
            <summary>
            Flag to enable enhanced log context. This adds the following enrich calls:
            - WithClientAgent
            - WithClientIp
            - WithExceptionDetails
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.LogToConsole">
            <summary>
            Flag to enable console sink
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.LogToFile">
            <summary>
            Flag to enable File sink
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.LogToSentry">
            <summary>
            Flag to enable Sentry sink
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.LogToSeq">
            <summary>
            Flag to enable Seq sink
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.MinimumLevel">
            <summary>
            Log events bellow this level are silently dropped
            </summary>
        </member>
        <member name="P:Speckle.Core.Logging.SpeckleLogConfiguration.SentryDns">
            <summary>
            Flag to override the default Sentry DNS
            </summary>
        </member>
        <member name="M:Speckle.Core.Logging.SpeckleLogConfiguration.#ctor(Serilog.Events.LogEventLevel,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Default SpeckleLogConfiguration constructor.
            These are the sane defaults we should be using across connectors.
            </summary>
            <param name="minimumLevel">Log events bellow this level are silently dropped</param>
            <param name="logToConsole">Flag to enable console log sink</param>
            <param name="logToSeq">Flag to enable Seq log sink</param>
            <param name="logToSentry">Flag to enable Sentry log sink</param>
            <param name="logToFile">Flag to enable File log sink</param>
            <param name="enhancedLogContext">Flag to enable enhanced context on every log event</param>
        </member>
        <member name="T:Speckle.Core.Logging.SpeckleLog">
            <summary>
            Configurator class for a standardized logging system across Speckle (sharp).
            </summary>
        </member>
        <member name="M:Speckle.Core.Logging.SpeckleLog.Initialize(System.String,System.String,Speckle.Core.Logging.SpeckleLogConfiguration)">
            <summary>
            Initialize logger configuration for a global Serilog.Log logger.
            </summary>
        </member>
        <member name="M:Speckle.Core.Logging.SpeckleLog.CreateConfiguredLogger(System.String,System.String,Speckle.Core.Logging.SpeckleLogConfiguration)">
            <summary>
            Create a new fully configured Logger instance.
            </summary>
            <param name="hostApplicationName">Name of the application using this SDK ie.: "Rhino"</param>
            <param name="hostApplicationVersion">Public version slug of the application using this SDK ie.: "2023"</param>
            <param name="logConfiguration">Input configuration object.</param>
            <returns>Logger instance</returns>
        </member>
        <member name="T:Speckle.Core.Logging.SpeckleNonUserFacingException">
            <summary>
            These are exceptions who's message is not user friendly
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.ApplicationObject">
            <summary>
            A simple wrapper to keep track of the relationship between speckle objects and their host-application siblings in cases where the
            <see cref="P:Speckle.Core.Models.Base.applicationId"/> cannot correspond with the <see cref="P:Speckle.Core.Models.ApplicationObject.CreatedIds"/> (ie, on receiving operations).
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.applicationId">
            <summary>
            ID of the object from host application that generated it.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Container">
            <summary>
            The container for the object in the native application
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Convertible">
            <summary>
            Indicates if conversion is supported by the converter
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Fallback">
            <summary>
            The fallback values if direct conversion is not available, typically displayValue
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.OriginalId">
            <summary>
            The Speckle id (on receive) or native id (on send)
            </summary>
            <remarks>
            Used to retrieve this object in <code>ProgressReport.GetReportObject()</code>, typically to pass between connectors and converters
            </remarks>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Descriptor">
            <summary>
            A descriptive string to describe the object. Use the object type as default.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.CreatedIds">
            <summary>
            The created object ids associated with this object
            </summary>
            <remarks>
            On send, this is currently left empty as generating Speckle ids would be performance expensive
            </remarks>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Status">
            <summary>
            Conversion status of object
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Log">
            <summary>
            Conversion notes or other important information to expose to the user
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ApplicationObject.Converted">
            <summary>
            Converted objects corresponding to this object
            </summary>
            <remarks>
            Used during receive for convenience, corresponds to CreatedIds
            </remarks>
        </member>
        <member name="T:Speckle.Core.Models.DetachProperty">
            <summary>
            <para>Flags an object's property as being detachable.</para>
            <para>If set to true the default serialiser will persist it separately, and add a reference to the property's value in the original object.</para>
            <para>Only applies to properties of types derived from the Base class.</para>
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.DetachProperty.#ctor(System.Boolean)">
            <summary>
            <para>Flags an object's property as being detachable.</para>
            <para>If set to true the default serialiser will persist it separately, and add a reference to the property's value in the original object.</para>
            <para>Only applies to properties of types derived from the Base class.</para>
            </summary>
            <param name="detachable">Whether to detach the property or not.</param>
        </member>
        <member name="T:Speckle.Core.Models.Chunkable">
            <summary>
            Flags a list or array as splittable into chunks during serialisation. These chunks will be recomposed on deserialisation into the original list. Note: this attribute should be used in conjunction with <see cref="T:Speckle.Core.Models.DetachProperty"/>.
            <para>Use this attribute on properties that can become very long and are not worth detaching into individual elements.</para>
            <para>Objects per chunk: for simple types, like numbers, use a high value (>10000); for other objects, use a more conservative number depending on their serialised size.</para>
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.Base">
            <summary>
            Base class for all Speckle object definitions. Provides unified hashing, type extraction and serialisation.
            <para>When developing a speckle kit, use this class as a parent class.</para>
            <para><b>Dynamic properties naming conventions:</b></para>
            <para>👉 "__" at the start of a property means it will be ignored, both for hashing and serialisation (e.g., "__ignoreMe").</para>
            <para>👉 "@" at the start of a property name means it will be detached (when serialised with a transport) (e.g.((dynamic)obj)["@meshEquivalent"] = ...) .</para>
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.Base.id">
            <summary>
            A speckle object's id is an unique hash based on its properties. <b>NOTE: this field will be null unless the object was deserialised from a source. Use the <see cref="M:Speckle.Core.Models.Base.GetId(System.Boolean)"/> function to get it.</b>
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.Base.totalChildrenCount">
            <summary>
            This property will only be populated if the object is retreieved from storage. Use <see cref="M:Speckle.Core.Models.Base.GetTotalChildrenCount"/> otherwise.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.Base.applicationId">
            <summary>
            Secondary, ideally host application driven, object identifier.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.Base.speckle_type">
            <summary>
            Holds the type information of this speckle object, derived automatically
            from its assembly name and inheritance.
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.Base.GetId(System.Boolean)">
            <summary>
            Calculates the id (a unique hash) of this object.
            </summary>
            <remarks>
            This method fully serialize the object and any referenced objects. This has a tangible cost and should be avoided.<br/>
            Objects retrieved from a <see cref="T:Speckle.Core.Transports.ITransport"/> already have a <see cref="P:Speckle.Core.Models.Base.id"/> property populated<br/>
            The hash of a decomposed object differs from the hash of a non-decomposed object.
            </remarks>
            <param name="decompose">If <see langword="true"/>, will decompose the object in the process of hashing.</param>
            <returns>the resulting id (hash)</returns>
        </member>
        <member name="M:Speckle.Core.Models.Base.GetTotalChildrenCount">
            <summary>
            Attempts to count the total number of detachable objects.
            </summary>
            <returns>The total count of the detachable children + 1 (itself).</returns>
        </member>
        <member name="M:Speckle.Core.Models.Base.ShallowCopy">
            <summary>
            Creates a shallow copy of the current base object.
            This operation does NOT copy/duplicate the data inside each prop.
            The new object's property values will be pointers to the original object's property value.
            </summary>
            <returns>A shallow copy of the original object.</returns>
        </member>
        <member name="M:Speckle.Core.Models.Base.GetId(Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Models.Base.GetId(System.Boolean)"/>
        </member>
        <member name="M:Speckle.Core.Models.Base.GetId(System.Boolean,Speckle.Core.Api.SerializerVersion)">
            <inheritdoc cref="M:Speckle.Core.Models.Base.GetId(System.Boolean)"/>
        </member>
        <member name="P:Speckle.Core.Models.Blob.id">
            <summary>
            For blobs, the id is the same as the file hash. Please note, when deserialising, the id will be set from the original hash generated on sending.
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.Collection">
            <summary>
            A simple container for organising objects within a model and preserving object hierarchy.
            A container is defined by a human-readable <see cref="P:Speckle.Core.Models.Collection.name"/>, a unique <see cref="P:Speckle.Core.Models.Base.applicationId"/>, and its list of contained <see cref="P:Speckle.Core.Models.Collection.elements"/>.
            The <see cref="P:Speckle.Core.Models.Collection.elements"/> can include an unrestricted number of <see cref="T:Speckle.Core.Models.Base"/> objects including additional nested <see cref="T:Speckle.Core.Models.Collection"/>s.
            </summary>
            <remarks>
            A <see cref="T:Speckle.Core.Models.Collection"/> can be for example a Layer in Rhino/AutoCad, a collection in Blender, or a Category in Revit.
            The location of each collection in the hierarchy of collections in a commit will be retrieved through commit traversal.
            </remarks>
        </member>
        <member name="M:Speckle.Core.Models.Collection.#ctor(System.String,System.String)">
            <summary>
            Constructor for a basic collection.
            </summary>
            <param name="name">The human-readable name of this collection</param>
            <param name="collectionType"></param>
        </member>
        <member name="P:Speckle.Core.Models.Collection.name">
            <summary>
            The human-readable name of the <see cref="T:Speckle.Core.Models.Collection"/>.
            </summary>
            <remarks>This name is not necessarily unique within a commit. Set the applicationId for a unique identifier.</remarks>
        </member>
        <member name="P:Speckle.Core.Models.Collection.collectionType">
            <summary>
            The type of this collection
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.Collection.elements">
            <summary>
            The elements contained in this <see cref="T:Speckle.Core.Models.Collection"/>.
            </summary>
            <remarks>
            This can include additional nested <see cref="T:Speckle.Core.Models.Collection"/>s.
            </remarks>
        </member>
        <member name="T:Speckle.Core.Models.CommitObjectBuilder`1">
            <summary>
            Abstract Builder class for a root commit <see cref="T:Speckle.Core.Models.Base"/> object.
            </summary>
            <typeparam name="TNativeObjectData">The native object data type needed as input for building <see cref="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions"/></typeparam>
            <remarks>
            It is designed to be inherited by a host app specific implementation,
            to give connectors flexibility in constructing their objects.
            Inheritors should also create some function to add
            </remarks>
        </member>
        <member name="F:Speckle.Core.Models.CommitObjectBuilder`1.ROOT">
            <summary>Special appId symbol for the root object</summary>
        </member>
        <member name="P:Speckle.Core.Models.CommitObjectBuilder`1.Converted">
            <summary>app id -> base</summary>
        </member>
        <member name="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions">
            <summary>Base -> NestingInstructions ordered by priority</summary>
        </member>
        <member name="M:Speckle.Core.Models.CommitObjectBuilder`1.IncludeObject(Speckle.Core.Models.Base,`0)">
            <summary>
            Given the parameters, builds connector specific <see cref="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions"/>
            to be applied when <see cref="M:Speckle.Core.Models.CommitObjectBuilder`1.BuildCommitObject(Speckle.Core.Models.Base)"/> is called.
            </summary>
            <param name="conversionResult"></param>
            <param name="nativeElement"></param>
        </member>
        <member name="M:Speckle.Core.Models.CommitObjectBuilder`1.BuildCommitObject(Speckle.Core.Models.Base)">
            <summary>
            Iterates through the converted objects applying
            </summary>
            <remarks>
            Can be overriden to adjust exactly which objects get automatically applied,
            or to inject additional items into the <see cref="P:Speckle.Core.Models.CommitObjectBuilder`1.Converted"/> dict that should not be automatically applied.
            </remarks>
            <param name="rootCommitObject"></param>
        </member>
        <member name="M:Speckle.Core.Models.CommitObjectBuilder`1.SetRelationship(Speckle.Core.Models.Base,System.Collections.Generic.IList{Speckle.Core.Models.NestingInstructions})">
            <summary>
            Sets information on how a given object should be nested in the commit tree.
            <paramref name="nestingInstructionsList"/> encodes the order in which we should try and nest the given <paramref name="conversionResult"/>
            when <see cref="M:Speckle.Core.Models.CommitObjectBuilder`1.BuildCommitObject(Speckle.Core.Models.Base)"/> is called
            </summary>
            <param name="conversionResult">The object to be nested</param>
            <param name="nestingInstructionsList">Information about how the object ideally should be nested, in order of priority</param>
        </member>
        <member name="M:Speckle.Core.Models.CommitObjectBuilder`1.ApplyRelationships(System.Collections.Generic.IEnumerable{Speckle.Core.Models.Base},Speckle.Core.Models.Base)">
            <summary>
            For each object in <paramref name="toAdd"/>
            <inheritdoc cref="M:Speckle.Core.Models.CommitObjectBuilder`1.ApplyRelationship(Speckle.Core.Models.Base,Speckle.Core.Models.Base)"/>
            </summary>
            <param name="toAdd"></param>
            <param name="rootCommitObject"></param>
        </member>
        <member name="M:Speckle.Core.Models.CommitObjectBuilder`1.ApplyRelationship(Speckle.Core.Models.Base,Speckle.Core.Models.Base)">
            <summary>
            Will attempt to find and nest the <paramref name="current"/> object
            under the first valid parent according to the <see cref="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions"/> <see cref="P:Speckle.Core.Models.CommitObjectBuilder`1.Converted"/> dictionary.
            </summary>
            <remarks>
            A parent is considered valid if
            1. Is non null
            2. Is in the <see cref="P:Speckle.Core.Models.CommitObjectBuilder`1.Converted"/> dictionary
            3. Has (or can dynamically accept) a <see cref="T:System.Collections.IList"/> typed property with the propName specified by the <see cref="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions"/> item
            4. Said <see cref="T:System.Collections.IList"/> can accept the <paramref name="current"/> object's type
            </remarks>
            <param name="current"></param>
            <param name="rootCommitObject"></param>
            <exception cref="T:System.InvalidOperationException">Thrown when no valid parent was found for <parameref name="current"/> given <see cref="F:Speckle.Core.Models.CommitObjectBuilder`1._nestingInstructions"/></exception>
        </member>
        <member name="T:Speckle.Core.Models.DynamicBase">
            <summary>
            Base class implementing a bunch of nice dynamic object methods, like adding and removing props dynamically. Makes c# feel like json.
            <para>Orginally adapted from Rick Strahl 🤘</para>
            <para>https://weblog.west-wind.com/posts/2012/feb/08/creating-a-dynamic-extensible-c-expando-object</para>
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBase.DEFAULT_INCLUDE_MEMBERS">
            <summary>
            Default <see cref="T:Speckle.Core.Models.DynamicBaseMemberType"/> value for <see cref="M:Speckle.Core.Models.DynamicBase.GetMembers(Speckle.Core.Models.DynamicBaseMemberType)"/>
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBase._properties">
            <summary>
            The actual property bag, where dynamically added props are stored.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.DynamicBase.Item(System.String)">
            <summary>
            Sets and gets properties using the key accessor pattern.
            </summary>
            <example>
            <c>myObject["superProperty"] = 42;</c>
            </example>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <inheritdoc />
            <summary>
            Gets properties via the dot syntax.
            <para><c>((dynamic)myObject).superProperty;</c></para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            Sets properties via the dot syntax.
            <para><pre>((dynamic)myObject).superProperty = something;</pre></para>
            </summary>
            <param name="binder"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetDynamicMemberNames">
            <summary>
            Gets all of the property names on this class, dynamic or not.
            </summary> <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetInstanceMembersNames">
            <summary>
            Gets the names of the defined class properties (typed).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetInstanceMembers">
            <summary>
            Gets the defined (typed) properties of this object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetMemberNames">
            <summary>
            Gets the names of the typed and dynamic properties that don't have a [SchemaIgnore] attribute.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetMembers(Speckle.Core.Models.DynamicBaseMemberType)">
            <summary>
             Gets the typed and dynamic properties.
            </summary>
            <param name="includeMembers">Specifies which members should be included in the resulting dictionary. Can be concatenated with "|"</param>
            <returns>A dictionary containing the key's and values of the object.</returns>
        </member>
        <member name="M:Speckle.Core.Models.DynamicBase.GetDynamicMembers">
            <summary>
            Gets the dynamically added property names only.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Speckle.Core.Models.IgnoreTheItemAttribute">
            <summary>
            This attribute is used internally to hide the this[key]{get; set;} property from inner reflection on members.
            For more info see this discussion: https://speckle.community/t/why-do-i-keep-forgetting-base-objects-cant-use-item-as-a-dynamic-member/3246/5
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.DynamicBaseMemberType">
            <summary>
            Represents all different types of members that can be returned by <see cref="M:Speckle.Core.Models.DynamicBase.GetMembers(Speckle.Core.Models.DynamicBaseMemberType)"/>
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.Instance">
            <summary>
            The typed members of the DynamicBase object
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.Dynamic">
            <summary>
            The dynamically added members of the DynamicBase object
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.Obsolete">
            <summary>
            The typed members flagged with <see cref="T:System.ObsoleteAttribute"/> attribute.
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.SchemaIgnored">
            <summary>
            The typed members flagged with <see cref="T:Speckle.Core.Kits.SchemaIgnore"/> attribute.
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.SchemaComputed">
            <summary>
            The typed methods flagged with TODO:
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.InstanceAll">
            <summary>
            All the typed members, including ones with <see cref="T:System.ObsoleteAttribute"/> or <see cref="T:Speckle.Core.Kits.SchemaIgnore"/> attributes.
            </summary>
        </member>
        <member name="F:Speckle.Core.Models.DynamicBaseMemberType.All">
            <summary>
            All the members, including dynamic and instance members flagged with <see cref="T:System.ObsoleteAttribute"/> or <see cref="T:Speckle.Core.Kits.SchemaIgnore"/> attributes
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.Extensions.BaseExtensions.BaseRecursionBreaker">
            <summary>
            Provides access to each base object in the traverse function, and decides whether the traverse function should continue traversing it's children or not.
            </summary>
            <remarks>
            Should return 'true' if you wish to stop the traverse behaviour, 'false' otherwise.
            </remarks>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.Flatten(Speckle.Core.Models.Base,Speckle.Core.Models.Extensions.BaseExtensions.BaseRecursionBreaker)">
            <summary>
            Traverses through the <paramref name="root"/> object and its children.
            Only traverses through the first occurrence of a <see cref="T:Speckle.Core.Models.Base"/> object (to prevent infinite recursion on circular references)
            </summary>
            <param name="root">The root object of the tree to flatten</param>
            <param name="recursionBreaker">Optional predicate function to determine whether to break (or continue) traversal of a <see cref="T:Speckle.Core.Models.Base"/> object's children.</param>
            <returns>A flat List of <see cref="T:Speckle.Core.Models.Base"/> objects.</returns>
            <seealso cref="M:Speckle.Core.Models.Extensions.BaseExtensions.Traverse(Speckle.Core.Models.Base,Speckle.Core.Models.Extensions.BaseExtensions.BaseRecursionBreaker)"/>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.Traverse(Speckle.Core.Models.Base,Speckle.Core.Models.Extensions.BaseExtensions.BaseRecursionBreaker)">
            <summary>
            Depth-first traversal of the specified <paramref name="root"/> object and all of its children as a deferred Enumerable, with a <paramref name="recursionBreaker"/> function to break the traversal.
            </summary>
            <param name="root">The <see cref="T:Speckle.Core.Models.Base"/> object to traverse.</param>
            <param name="recursionBreaker">Predicate function to determine whether to break (or continue) traversal of a <see cref="T:Speckle.Core.Models.Base"/> object's children.</param>
            <returns>Deferred Enumerable of the <see cref="T:Speckle.Core.Models.Base"/> objects being traversed (iterable only once).</returns>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedProp(Speckle.Core.Models.Base,System.String)">
            <summary>
            see <see cref="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedPropName(Speckle.Core.Models.Base,System.String)"/>
            </summary>
            <remarks><inheritdoc cref="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedPropName(Speckle.Core.Models.Base,System.String)"/></remarks>
            <param name="speckleObject"></param>
            <returns>elements</returns>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.SetDetachedProp(Speckle.Core.Models.Base,System.String,System.Object)">
            <summary>
            see <see cref="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedPropName(Speckle.Core.Models.Base,System.String)"/>
            </summary>
            <remarks><inheritdoc cref="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedPropName(Speckle.Core.Models.Base,System.String)"/></remarks>
            <param name="speckleObject"></param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.GetDetachedPropName(Speckle.Core.Models.Base,System.String)">
            <summary>
            Returns <paramref name="propName"/> if the given <paramref name="speckleObject"/> has an instance prop of the same name
            otherwise returns <paramref name="propName"/> with a '@' prefix for dynamic detaching.
            </summary>
            <remarks>
            These functions are workarounds for '@' prefixed property names being treated as unique keys.
            And is useful in circumstances where you want to get/set detached properties without caring about the <see cref="T:Speckle.Core.Models.Base"/> derived class definition
            This behaviour, and these functions may be changed in future releases.
            </remarks>
            <param name="speckleObject"></param>
            <param name="propName">the property name to check for</param>
            <returns>detached property name</returns>
        </member>
        <member name="M:Speckle.Core.Models.Extensions.BaseExtensions.IsDisplayableObject(Speckle.Core.Models.Base)">
            <summary>
            Checks if an object "is displayable" i.e. has a displayValue property that is a list of base.
            This is to mirror the selection logic of our viewer package, where any "displayable object" will become
            a single selectable entity.
            </summary>
            <param name="speckleObject">The Base object to check.</param>
            <returns>True if the object is displayable, false otherwise.</returns>
        </member>
        <member name="T:Speckle.Core.Models.Abstract">
            <summary>
            Wrapper around other, third party, classes that are not coming from a speckle kit.
            <para>Serialization and deserialization of the base object happens through default Newtonsoft converters. If your object does not de/serialize correctly, this class will not prevent that from happening.</para>
            <para><b>Limitations:</b></para>
            <para>- Base object needs to be serializable.</para>
            <para>- Inline collection declarations with values do not behave correctly.</para>
            <para>- Your class needs to have a void constructor.</para>
            <para>- Probably more. File a bug!</para>
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.Abstract.#ctor">
            <summary>
            See <see cref="T:Speckle.Core.Models.Abstract"/> for limitations of this approach.
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.Abstract.#ctor(System.Object)">
            <summary>
            See <see cref="T:Speckle.Core.Models.Abstract"/> for limitations of this approach.
            </summary>
            <param name="_original"></param>
        </member>
        <member name="P:Speckle.Core.Models.Abstract.base">
            <summary>
            The original object.
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.DataChunk">
            <summary>
            <para>In short, this helps you chunk big things into smaller things.</para>
            See the following <see href="https://pics.me.me/chunky-boi-57848570.png">reference.</see>
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ProgressReport.ConversionLog">
            <summary>
            Keeps track of the conversion process
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ProgressReport.ConversionErrors">
            <summary>
            Keeps track of errors in the conversions.
            </summary>
        </member>
        <member name="P:Speckle.Core.Models.ProgressReport.OperationErrors">
            <summary>
            Keeps track of HANDLED errors that occur during send/recieve commands.
            </summary>
            <remarks>
            Handled errors specific to the conversion, should be added to ConversionErrors
            Unhandleable errors (i.e. that lead to the entire send/receive failing) should be Thrown instead.
            </remarks>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.DefaultTraversal.CreateTraverseFunc(Speckle.Core.Kits.ISpeckleConverter)">
            <summary>
            Default traversal rule that ideally should be used by all connectors
            </summary>
            <remarks>
            Treats convertable objects <see cref="M:Speckle.Core.Kits.ISpeckleConverter.CanConvertToNative(Speckle.Core.Models.Base)"/> and objects with displayValues as "convertable" such that only elements and dynamic props will be traversed
            </remarks>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.DefaultTraversal.CreateRevitTraversalFunc(Speckle.Core.Kits.ISpeckleConverter)">
            <summary>
            Traverses until finds a convertable object then HALTS deeper traversal
            </summary>
            <remarks>
            Current Revit connector does traversal,
            so this traversal is a shallow traversal for directly convertable objects,
            and a deep traversal for all other types
            </remarks>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.DefaultTraversal.CreateBIMTraverseFunc(Speckle.Core.Kits.ISpeckleConverter)">
            <summary>
            Traverses until finds a convertable object (or fallback) then traverses members
            </summary>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.GraphTraversal`1.Traverse(Speckle.Core.Models.Base)">
            <summary>
            Given <paramref name="root"/> object, will recursively traverse members according to the provided traversal rules.
            </summary>
            <param name="root">The object to traverse members</param>
            <returns>Lazily returns <see cref="T:Speckle.Core.Models.Base"/> objects found during traversal (including <paramref name="root"/>), wrapped within a <see cref="T:Speckle.Core.Models.GraphTraversal.TraversalContext"/></returns>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.GraphTraversal`1.TraverseMember(System.Object)">
            <summary>
            Traverses supported Collections yielding <see cref="T:Speckle.Core.Models.Base"/> objects.
            Does not traverse <see cref="T:Speckle.Core.Models.Base"/>, only (potentially nested) collections.
            </summary>
            <param name="value">The value to traverse</param>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.ITraversalRule">
            <summary>
            Interface for a definition of conditional traversal of <see cref="T:Speckle.Core.Models.Base"/> objects.
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.ITraversalRule.MembersToTraverse(Speckle.Core.Models.Base)">
            <param name="b"></param>
            <returns>The member names to traverse</returns>
            <remarks>Return may include member names <paramref name="b"/> doesn't have</remarks>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.ITraversalRule.DoesRuleHold(Speckle.Core.Models.Base)">
            <summary>
            Evaluates the traversal rule given <paramref name="o"/>
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.DefaultRule">
            <summary>
            The "traverse none" rule that always holds true
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.TraversalRule">
            <summary>
            A traversal rule defines the conditional traversal behaviour when traversing a given <see cref="T:Speckle.Core.Models.Base"/> objects.
            Specifies what members to traverse if any provided <see cref="F:Speckle.Core.Models.GraphTraversal.TraversalRule._conditions"/> are met.
            </summary>
            <remarks>Follows the builder pattern to ensure that a rule is complete before usable, see usages</remarks>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.TraversalRule.NewTraversalRule">
            <returns>a new Traversal Rule to be initialised using the Builder Pattern interfaces</returns>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.ITraversalBuilderWhen">
            <summary>
            Interface for traversal rule in a building (unusable) state
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.ITraversalBuilderWhen.When(Speckle.Core.Models.GraphTraversal.WhenCondition)">
            <summary>
            Adds a condition to this rule. This rule will hold true when ANY of its conditions holds true.
            </summary>
            <param name="condition"></param>
            <returns>Traversal rule in a building (unusable) state</returns>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.SelectMembers">
            <summary>
            Delegate for selecting members (by member name) of an given <see cref="T:Speckle.Core.Models.Base"/> object
            </summary>
        </member>
        <member name="T:Speckle.Core.Models.GraphTraversal.ITraversalBuilderTraverse">
            <summary>
            Interface for traversal rule in a building (unusable) state
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.GraphTraversal.ITraversalBuilderTraverse.ContinueTraversing(Speckle.Core.Models.GraphTraversal.SelectMembers)">
            <seealso cref="M:Speckle.Core.Models.GraphTraversal.ITraversalRule.MembersToTraverse(Speckle.Core.Models.Base)"/>
            <param name="membersToTraverse">Function returning the members that should be traversed for objects where this rule holds <see langword = "true"/></param>
            <returns>Traversal rule in a usable state</returns>
        </member>
        <member name="T:Speckle.Core.Models.NestingInstructions">
            <summary>
            Container for a reference to a parent's applicationId and an Action to
            execute in order to nest the child on the parent
            </summary>
        </member>
        <member name="M:Speckle.Core.Models.Utilities.HashString(System.String,Speckle.Core.Models.Utilities.HashingFunctions)">
            <summary>
            Wrapper method around hashing functions..
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.Utilities.GetApplicationProps(System.Object,System.Type,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Retrieves the simple type properties of an object
            </summary>
            <param name="o"></param>
            <param name="t"></param>
            <param name="getParentProps">Set to true to also retrieve simple props of direct parent type</param>
            <param name="ignore">Names of props to ignore</param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Models.Utilities.SetApplicationProps(System.Object,System.Type,Speckle.Core.Models.Base)">
            <summary>
            Sets the properties of an object with the properties of a base object
            </summary>
            <param name="o"></param>
            <param name="t"></param>
            <param name="props">The base class object representing application props</param>
        </member>
        <member name="M:Speckle.Core.Models.Utilities.SplitList``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Chunks a list into pieces.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="chunkSize"></param>
            <returns></returns>
        </member>
        <member name="F:Speckle.Core.Serialisation.BaseObjectDeserializerV2.TYPE_DISCRIMINATOR">
            <summary>
            Property that describes the type of the object.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectDeserializerV2.ReadTransport">
            <summary>
            The sync transport. This transport will be used synchronously.
            </summary>
        </member>
        <member name="M:Speckle.Core.Serialisation.BaseObjectDeserializerV2.Deserialize(System.String)">
            <param name="rootObjectJson">The JSON string of the object to be deserialized <see cref="T:Speckle.Core.Models.Base"/></param>
            <returns>A <see cref="T:Speckle.Core.Models.Base"/> typed object deserialized from the <paramref name="rootObjectJson"/></returns>
            <exception cref="T:System.InvalidOperationException">Thrown when <see cref="F:Speckle.Core.Serialisation.BaseObjectDeserializerV2._isBusy"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="rootObjectJson"/> was null</exception>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleDeserializeException"><paramref name="rootObjectJson"/> cannot be deserialised to type <see cref="T:Speckle.Core.Models.Base"/></exception>
        </member>
        <member name="M:Speckle.Core.Serialisation.BaseObjectDeserializerV2.DeserializeTransportObject(System.String)">
            <param name="objectJson"></param>
            <returns>The deserialized object</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="objectJson"/> was null</exception>
            <exception cref="T:Speckle.Newtonsoft.Json.JsonReaderException"><paramref name="objectJson"/> was not valid JSON</exception>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleDeserializeException">Failed to deserialize <see cref="T:Speckle.Newtonsoft.Json.Linq.JObject"/> to the target type</exception>
        </member>
        <member name="T:Speckle.Core.Serialisation.BaseObjectSerializer">
            <summary>
            Json converter that handles base speckle objects. Enables detachment and
            simultaneous transport (persistence) of objects.
            </summary>
        </member>
        <member name="F:Speckle.Core.Serialisation.BaseObjectSerializer.TypeDiscriminator">
            <summary>
            Property that describes the type of the object.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializer.ReadTransport">
            <summary>
            The sync transport. This transport will be used synchronously.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializer.WriteTransports">
            <summary>
            List of transports to write to.
            </summary>
        </member>
        <member name="M:Speckle.Core.Serialisation.BaseObjectSerializer.ResetAndInitialize">
            <summary>
            Reinitializes the lineage, and other variables that get used during the
            json writing process.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializer.DetachLineage">
            <summary>
            Keeps track of wether current property pointer is marked for detachment.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializer.Lineage">
            <summary>
            Keeps track of the hash chain through the object tree.
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializer.RefMinDepthTracker">
            <summary>
            Dictionary of object if and its subsequent closure table (a dictionary of hashes and min depth at which they are found).
            </summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializerV2.WriteTransports">
            <summary>The sync transport. This transport will be used synchronously.</summary>
        </member>
        <member name="P:Speckle.Core.Serialisation.BaseObjectSerializerV2.Elapsed">
            <summary>The current total elapsed time spent serializing</summary>
        </member>
        <member name="M:Speckle.Core.Serialisation.BaseObjectSerializerV2.Serialize(Speckle.Core.Models.Base)">
            <param name="baseObj">The object to serialize</param>
            <returns>The serialized JSON</returns>
            <exception cref="T:System.InvalidOperationException">The serializer is busy (already serializing an object)</exception>
            <exception cref="T:Speckle.Core.Transports.TransportException">Failed to save object in one or more <see cref="P:Speckle.Core.Serialisation.BaseObjectSerializerV2.WriteTransports"/></exception>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleSerializeException">Failed to extract (pre-serialize) properties from the <paramref name="baseObj"/></exception>
            <exception cref="T:System.OperationCanceledException">One or more <see cref="P:Speckle.Core.Serialisation.BaseObjectSerializerV2.WriteTransports"/>'s cancellation token requested cancel</exception>
        </member>
        <member name="M:Speckle.Core.Serialisation.SerializationUtilities.BaseObjectSerializationUtilities.FlushCachedTypes">
            <summary>
            Flushes kit's (discriminator, type) cache. Useful if you're dynamically loading more kits at runtime, that provide better coverage of what you're deserialising, and it's now somehow poisoned because the higher level types were not originally available.
            </summary>
        </member>
        <member name="T:Speckle.Core.Transports.ITransport">
            <summary>
            Interface defining the contract for transport implementations.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.TransportName">
            <summary>
            Human readable name for the transport
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.TransportContext">
            <summary>
            Extra descriptor properties of the given transport.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.Elapsed">
            <summary>
             Show how much time the transport was busy for.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.SavedObjectCount">
            <summary>
             Show how many objects the transport saved.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.CancellationToken">
            <summary>
            Should be checked often and gracefully stop all in progress sending if requested.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.OnProgressAction">
            <summary>
            Used to report progress during the transport's longer operations.
            </summary>
        </member>
        <member name="P:Speckle.Core.Transports.ITransport.OnErrorAction">
            <summary>
            Used to report errors during the transport's longer operations.
            </summary>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.BeginWrite">
            <summary>
            Signals to the transport that writes are about to begin.
            </summary>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.EndWrite">
            <summary>
            Signals to the transport that no more items will need to be written.
            </summary>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.SaveObject(System.String,System.String)">
            <summary>
            Saves an object.
            </summary>
            <param name="id">The hash of the object.</param>
            <param name="serializedObject">The full string representation of the object</param>
            <exception cref="T:Speckle.Core.Transports.TransportException">Failed to save object</exception>
            <exception cref="T:System.OperationCanceledException"><see cref="P:Speckle.Core.Transports.ITransport.CancellationToken"/> requested cancel</exception>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.SaveObject(System.String,Speckle.Core.Transports.ITransport)">
            <summary>
            <inheritdoc cref="M:Speckle.Core.Transports.ITransport.SaveObject(System.String,System.String)"/>
            Retrieving its serialised version from the provided transport.
            </summary>
            <param name="id"><inheritdoc cref="M:Speckle.Core.Transports.ITransport.SaveObject(System.String,System.String)"/></param>
            <param name="sourceTransport">The transport from where to retrieve it.</param>
            <exception cref="T:Speckle.Core.Transports.TransportException">Failed to save object</exception>
            <exception cref="T:System.OperationCanceledException"><see cref="P:Speckle.Core.Transports.ITransport.CancellationToken"/> requested cancel</exception>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.WriteComplete">
            <summary>
            Awaitable method to figure out whether writing is completed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.GetObject(System.String)">
            <param name="id">The object's hash.</param>
            <returns>The serialized object data, or <see langword="null"/> if the transport cannot find the object</returns>
            <exception cref="T:System.OperationCanceledException"><see cref="P:Speckle.Core.Transports.ITransport.CancellationToken"/> requested cancel</exception>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.CopyObjectAndChildren(System.String,Speckle.Core.Transports.ITransport,System.Action{System.Int32})">
            <summary>
            Copies the parent object and all its children to the provided transport.
            </summary>
            <param name="id">The id of the object you want to copy.</param>
            <param name="targetTransport">The transport you want to copy the object to.</param>
            <param name="onTotalChildrenCountKnown">(Optional) an <see cref="T:System.Action`1"/> that will be invoked once, when the number of object children to be copied over is known.</param>
            <returns>The string representation of the root object.</returns>
            <exception cref="T:System.ArgumentException">The provided arguments are not valid</exception>
            <exception cref="T:Speckle.Core.Transports.TransportException">The transport could not complete the operation</exception>
            <exception cref="T:System.OperationCanceledException"><see cref="P:Speckle.Core.Transports.ITransport.CancellationToken"/> requested cancel</exception>
        </member>
        <member name="M:Speckle.Core.Transports.ITransport.HasObjects(System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Checks if objects are present in the transport
            </summary>
            <param name="objectIds">List of object ids to check</param>
            <returns>A dictionary with the specified object ids as keys and boolean values, whether each object is present in the transport or not</returns>
            <exception cref="T:Speckle.Core.Transports.TransportException">The transport could not complete the operation</exception>
            <exception cref="T:System.OperationCanceledException"><see cref="P:Speckle.Core.Transports.ITransport.CancellationToken"/> requested cancel</exception>
        </member>
        <member name="T:Speckle.Core.Transports.MemoryTransport">
            <summary>
            An in memory storage of speckle objects.
            </summary>
        </member>
        <member name="T:Speckle.Core.Transports.ServerTransportV1">
            <summary>
            Sends data to a speckle server.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Speckle.Core.Transports.ServerTransportV1.ConsumeNewBatch" -->
        <member name="T:Speckle.Core.Transports.GzipContent">
            <summary>
            https://cymbeline.ch/2014/03/16/gzip-encoding-an-http-post-request-body/
            </summary>
        </member>
        <member name="T:Speckle.Core.Transports.ServerUtils.GzipContent">
            <remarks>
            https://cymbeline.ch/2014/03/16/gzip-encoding-an-http-post-request-body/
            </remarks>
        </member>
        <member name="P:Speckle.Core.Transports.ServerUtils.ServerApi.OnBatchSent">
            <summary>
            Callback when sending batches. Parameters: object count, total bytes sent
            </summary>
        </member>
        <member name="M:Speckle.Core.Transports.ServerTransport.#ctor(Speckle.Core.Credentials.Account,System.String,System.Int32,System.String)">
            <param name="account"></param>
            <param name="streamId"></param>
            <param name="timeoutSeconds"></param>
            <param name="blobStorageFolder">Defaults to <see cref="M:Speckle.Core.Helpers.SpecklePathProvider.BlobStoragePath(System.String)"/></param>
            <exception cref="T:System.ArgumentException"><paramref name="streamId"/> was not formatted as valid stream id</exception>
        </member>
        <member name="F:Speckle.Core.Transports.SQLiteTransport._writeTimer">
            <summary>
            Timer that ensures queue is consumed if less than MAX_TRANSACTION_SIZE objects are being sent.
            </summary>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.#ctor(System.String,System.String,System.String)">
            <summary>
            Connects to an SQLite DB at {<paramref name="basePath"/>}/{<paramref name="applicationName"/>}/{<paramref name="scope"/>}.db
            Will attempt to create db + directory structure as needed
            </summary>
            <param name="basePath">defaults to <see cref="M:Speckle.Core.Helpers.SpecklePathProvider.UserApplicationDataPath"/> if <see langword="null"/></param>
            <param name="applicationName">defaults to <c>"Speckle"</c> if <see langword="null"/></param>
            <param name="scope">defaults to <c>"Data"</c> if <see langword="null"/></param>
            <exception cref="T:Microsoft.Data.Sqlite.SqliteException">Failed to initialize a connection to the db</exception>
            <exception cref="T:Speckle.Core.Transports.TransportException">Path was invalid or could not be created</exception>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.Initialize">
            <exception cref="T:Microsoft.Data.Sqlite.SqliteException">Failed to initialize connection to the SQLite DB</exception>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.GetAllObjects">
            <summary>
            Returns all the objects in the store. Note: do not use for large collections.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.DeleteObject(System.String)">
            <summary>
            Deletes an object. Note: do not use for any speckle object transport, as it will corrupt the database.
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.UpdateObject(System.String,System.String)">
            <summary>
            Updates an object.
            </summary>
            <param name="hash"></param>
            <param name="serializedObject"></param>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.WriteComplete">
            <summary>
            Awaits untill write completion (ie, the current queue is fully consumed).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Speckle.Core.Transports.SQLiteTransport.WriteCompletionStatus">
            <summary>
            Returns true if the current write queue is empty and comitted.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.SaveObject(System.String,System.String)">
            <summary>
            Adds an object to the saving queue.
            </summary>
            <param name="id"></param>
            <param name="serializedObject"></param>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.SaveObjectSync(System.String,System.String)">
            <summary>
            Directly saves the object in the db.
            </summary>
            <param name="hash"></param>
            <param name="serializedObject"></param>
        </member>
        <member name="M:Speckle.Core.Transports.SQLiteTransport.GetObject(System.String)">
            <summary>
            Gets an object.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Speckle.Core.Transports.TransportHelpers.GetClosureTable(System.String)">
            <param name="objString">The Json object</param>
            <returns>The closure table</returns>
            <exception cref="T:Speckle.Core.Serialisation.SpeckleDeserializeException">Failed to deserialize the object into <see cref="T:Speckle.Core.Transports.TransportHelpers.Placeholder"/></exception>
        </member>
        <member name="M:Speckle.Core.Transports.Utilities.WaitUntil(System.Func{System.Boolean},System.Int32,System.Int32)">
            <summary>
            Waits until the provided function returns true.
            </summary>
            <param name="condition"></param>
            <param name="frequency"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
    </members>
</doc>
